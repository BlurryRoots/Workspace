#!/bin/bash

# Activate or deactivate photoanalysisd agent.
config_photoanalysis () {
	case $1 in
		off)
			launchctl kill -STOP gui/$UID/com.apple.photoanalysisd
		;;
		on)
			launchctl kill -CONT gui/$UID/com.apple.photoanalysisd
		;;
		*)
			echo "unreckognized command '$1"
			return 1
		;;
	esac
}

ws () {
	cd "$WS_CFG_PATH/.."
}

# Shows all available targets within makefile.
make_list_targets () {
	make -f "$1" -qp | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | sort -u
}

# Cuts off portion of a video at the front and back.
trim_video () {
	case $1 in
		cut)
			ffmpeg -ss $3 -to $4 -i "$2" -acodec copy "$5"
		;;
		*)
			echo "unreckognized command '$1'"
		;;
	esac
}

# Converts video to a series of images packaged in a gif container.
convert_to_gif () {
	if [ $# -ne 2 ]; then
		echo "convert_to_gif [IN_PATH] [OUT_PATH]"
		return 1
	fi

	local in_file=$1
	local out_file=$2

	ffmpeg -i "$in_file" \
		-filter_complex "[0:v] fps=12,scale=w=480:h=-1,split [a][b];[a] palettegen=stats_mode=single [p];[b][p] paletteuse=new=1" \
		"$out_file"
}

# Exports up to 2 audio channels from input file and creates mp3 from it.
convert_to_mp3 () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp3 [IN_PATH] [OUT_PATH]"
		return $#
	fi

	local in_file=$1
	local out_file=$2

	# -map a / strips artwork
	ffmpeg -i "$in_file" -vn -ar 44100 -ac 2 -b:a 96k -map a "$out_file"

	return $?
}

# Converst input to mp4 using gpu acceleration.
convert_to_mp4_gpu () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH]"
		return 1
	fi

	# local base_path="$(dirname $1)"
	# local filename_without_ext="$(basename $1 .mkv)"

	# local in_file="$base_path/$filename_without_ext.mkv"
	# local out_file="$base_path/$filename_without_ext.mp4"
	local in_file=$1
	local out_file=$2

	#ffmpeg -i "$in_file" -c:v libx264 "$out_file"
	ffmpeg -i "$in_file" -acodec copy -c:v h264_videotoolbox -pix_fmt yuv420p -profile:v main -level:v 3.1 "$out_file"

	return $?
}

# Converts input file to mp4.
convert_to_mp4 () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH]"
		return 1
	fi

	# local base_path="$(dirname $1)"
	# local filename_without_ext="$(basename $1 .mkv)"

	# local in_file="$base_path/$filename_without_ext.mkv"
	# local out_file="$base_path/$filename_without_ext.mp4"
	local in_file=$1
	local out_file=$2

	#ffmpeg -i "$in_file" -c:v libx264 "$out_file"
	ffmpeg -i "$in_file" -acodec copy -c:v libx264 -pix_fmt yuv420p -profile:v main -level:v 3.1 "$out_file"

	return $?
}

init_docker () {
	docker-machine start default
	eval "$(docker-machine env default)"
}

init_ssh () {
	eval `ssh-agent` && (
		for key in $(cat "$HOME/.ssh/keys"); do
			ssh-add "$HOME/.ssh/$key"
		done		
	)
}

fix_steam_lib32 () {
	find $HOME/.steam/root/ubuntu12_32/steam-runtime/*/usr/lib/ \
		-name "libstdc++.so.6" -exec mv "{}" "{}.bak" \; -print
}

open_pdf () {
	if [ $# -ne 1 ]; then
		echo "no file given!"
		return 1
	fi

	# double fork it !!!
	(mupdf "$1" &) &
}

#
calc () {
	[ $# -ne 1 ] && {
		echo "just one string with calculation pleazz!"
		return 1
	}

	local stuff="scale=2; $1"

	echo $stuff | bc
}

#
drossel () {
	[ $# -ne 2 ] && {
		echo "nöööööö"
		return 1
	}

	local iface="$1"
	local speed="$2"

	which wondershaper > /dev/null && {
		sudo wondershaper clear && \
		sudo wondershaper "$iface" "${speed}0" "${speed}0"
	} || {
		exit 1
	}
}

#
find_string () {
	[ $# -ne 2 ] && {
		echo "usage: find_string <directory> <searchstring>"
		return 1
	}

	find "$1" -type f | xargs -I{} fgrep --color=always -Hno "$2" "{}"

	return 0
}

#
show_connections () {
	sudo netstat -natp
}

#
find_here () {
	find . -iname "$1"
}

#
who_uses_port () {
	local port=$1

	lsof -Pnl +M -i4 | grep ":$port"

	[ $? -eq 1 ] && {
		echo "nobody uses port "$port
	}
}

# frontend for rsync
netcp () {
	local user="$1"
	local addr="$2"
	local port="$3"
	local src="$4"
	local dst="$5"

	rsync -aP -e "ssh -p$port" "$user@$addr:$src" "$dst"
}

# ex - archive extractor
# usage: ex <file>
ex () {
	if [ -f $1 ] ; then
		case $1 in
			*.tar.bz2)   tar xjf $1   ;;
			*.tar.gz)    tar xzf $1   ;;
			*.bz2)       bunzip2 $1   ;;
			*.rar)       unrar x $1   ;;
			*.gz)        gunzip $1    ;;
			*.tar)       tar xf $1    ;;
			*.tbz2)      tar xjf $1   ;;
			*.tgz)       tar xzf $1   ;;
			*.zip)       unzip $1     ;;
			*.Z)         uncompress $1;;
			*.7z)        7z x $1      ;;
			*)           echo "'$1' cannot be extracted via ex()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

cleanup_caches () {
	rm -rf ~/.thumbnails
	mkdir -p ~/.thumbnails

	rm -rf ~/.cache
	mkdir -p ~/.cache
}

#
top_biggies () {
	local search_path="$1"
	if ((0 == $#)); then
		search_path=./
	fi

	du -h "$search_path" | sort -rh | head -11
}

#
git-custom-rm-submodule () {
	if [ $# -ne 2 ]; then
	fi

	git submodule deinit -f -- "$1"
	rm -rf ".git/modules/$1"
	git rm --cached "$1"

}

#
git-custom-show-all-tags () {
	if [ "$1" = "-v" ]; then
		git log --no-walk --tags --pretty="%H %d" --decorate=full
	else
		git tag
	fi
}

#
git-custom-exterminate () {
	if [ "$1" = "" ]; then
		echo "You have to specifiy the path of the file to destroy!"
		exit
	fi

	echo "This will delete all references of $1!"
	echo "Please back up your data, before running this command!"
	echo "Continue?[y/n] > "

	read cont

	if [ "$cont" = "y" ]; then
		git filter-branch --force \
		--index-filter "git rm --cached --ignore-unmatch $1" \
		--prune-empty --tag-name-filter cat -- --all

		if [ $? -ne 0 ]; then
			echo "Something went wrong!"
		else
			echo "You rewrote history! Be proud of yourself!"
		fi
	else
		echo "Ending without rewrite."
	fi
}
