#!/bin/bash

bg-jobs-list () {
	ps -eo pid,pgid,tpgid,args | awk 'NR == 1 || ($3 != -1 && $2 != $3)'
}

reload-touchpad () {
	#sudo rmmod psmouse
	sudo modprobe psmouse synaptics_intertouch=1
}

colorgrid () {
	#https://unix.stackexchange.com/a/285956
	local first=16
	local second=0
	local third=0
	local four=0
	local five=0
	local six=0
	local seven=0

	while [ ${first} -lt 52 ]; do
		second=$[${first} + 36]
		third=$[${second} + 36]
		four=$[${third} + 36]
		five=$[${four} + 36]
		six=$[${five} + 36]
		seven=$[${six} + 36]
		if [ ${seven} -gt 250 ];then seven=$[${seven} - 251]; fi

		echo -en "   \033[38;5;$(echo ${first})m█ "
		printf "%03d" ${first}
		echo -en "   \033[38;5;$(echo ${second})m█ "
		printf "%03d" ${second}
		echo -en "   \033[38;5;$(echo ${third})m█ "
		printf "%03d" ${third}
		echo -en "   \033[38;5;$(echo ${four})m█ "
		printf "%03d" ${four}
		echo -en "   \033[38;5;$(echo ${five})m█ "
		printf "%03d" ${five}
		echo -en "   \033[38;5;$(echo ${six})m█ "
		printf "%03d" ${six}
		echo -en "   \033[38;5;$(echo ${seven})m█ "
		printf "%03d" ${seven}

		first=$[${first} + 1]
		printf '\r\n'
	done

	return 0
}

coredump-list () {
	sudo ls -lav /var/lib/apport/coredump
}

coredump-clean () {
	sudo rm -rf /var/lib/apport/coredump/*
}

berg () {
	case $1 in
		auf)
			sudo mkdir -p /media/sol/Windows
			sudo mount -o permissions,rw /dev/nvme0n1p3 /media/sol/Windows && \
				echo "Mount '/media/sol/Windows' ready."
		;;
		ab)
			sudo umount /media/sol/Windows && \
				echo "Mount '/media/sol/Windows' released."
		;;
		*)
			echo "unreckognized command '$1'. use either auf or ab"
			return 1
		;;
	esac

	return $?
}

fix-gpu-path () {
	local device_id=pci0000:00/0000:00:01.0/0000:01:00.0
	sudo \
		echo 1 > "/sys/devices/${device_id}/remove" \
	&&  echo 1 > "/sys/bus/pci/rescan"

	sudo ls -lav "/sys/devices/${device_id}/remove"
	sudo ls -lav "/sys/bus/pci/rescan"
}

python3-list-packages () {
	python3 -c "for dist in __import__('pkg_resources').working_set: print (dist.project_name.replace('Python', ''))"
}

portable_nproc () {
	# thanks to https://stackoverflow.com/a/45181694
	OS="$(uname -s)"
	if [ "$OS" = "Linux" ]; then
		NPROCS="$(nproc --all)"
	elif [ "$OS" = "Darwin" ] || \
		 [ "$(echo "$OS" | grep -q BSD)" = "BSD" ]; then
		NPROCS="$(sysctl -n hw.ncpu)"
	else
		NPROCS="$(getconf _NPROCESSORS_ONLN)"  # glibc/coreutils fallback
	fi
	echo "$NPROCS"
}

get_processor_count () {
	portable_nproc
}

cleanup_metadata () {
	exiftool -q -q -all:all= "$1" -o "$2"
}

cleanup_pdf () {
	# --------------------------------------------------------------------
	# Recursively find pdfs from the directory given as the first argument, 
	# otherwise search the current directory.
	# Use exiftool and qpdf (both must be installed and locatable on $PATH) 
	# to strip all top-level metadata from PDFs.
	#
	# Note - This only removes file-level metadata, not any metadata
	# in embedded images, etc. 
	#
	# Code is provided as-is, I take no responsibility for its use,
	# and I make no guarantee that this code works
	# or makes your PDFs "safe," whatever that means to you.
	#
	# You may need to enable execution of this script before using,
	# eg. chmod +x clean_pdf.sh
	#
	# example:
	# clean current directory:
	# >>> ./clean_pdf.sh
	#
	# clean specific directory:
	# >>> ./clean_pdf.sh some/other/directory
	# --------------------------------------------------------------------


	# Color Codes so that warnings/errors stick out
	GREEN="\e[32m"
	RED="\e[31m"
	CLEAR="\e[0m"

	# loop through all PDFs in first argument ($1),
	# or use '.' (this directory) if not given
	DIR="${1:-.}"

	echo "Cleaning PDFs in directory $DIR"

	# use find to locate files, pip to while read to get the
	# whole line instead of space delimited
	# Note -- this will find pdfs recursively!!
	find $DIR -type f -name "*.pdf" | while read -r i
	do
	  # output file as original filename with suffix _clean.pdf
	  TMP=${i%.*}_clean.pdf

	  # remove the temporary file if it already exists
	  if [ -f "$TMP" ]; then
		  rm "$TMP";
	  fi

	  exiftool -q -q -all:all= "$i" -o "$TMP"
	  qpdf --linearize --replace-input "$TMP"
	  echo -e $(printf "${GREEN}Processed ${RED}${i} ${CLEAR}as ${GREEN}${TMP}${CLEAR}")
	done
}

probe () {
	ffprobe -v quiet -print_format json -show_format -show_streams "$1" 2> /dev/null
}

set_boot_sound () {
	# %00 %80 %01 " "
	case $1 in
		off)
			sudo nvram SystemAudioVolume=" "
		;;
		on)
			sudo nvram -d SystemAudioVolume
		;;
		*)
			echo "unreckognized command '$1'. use either on or off"
			return 1
		;;
	esac
}

list_installed_applications () {
	for app in /Applications/*
	do
		mdls -name kMDItemCFBundleIdentifier "$app"
	done
}

make_timestamp () {
	echo $(date "+%Y%m%d%H%M%S")
}

replace_audio_stream () {
	#ffmpeg -i "$1" -i "$2" -c:v copy -map 0:v:0 -map 1:a:0 "$3"
	ffmpeg -i "$1" -stream_loop -1 -i "$2" -map 0:v -map 1:a -c:v copy -shortest "$3"
}

merge_to_mp3 () {
	# inspired by https://kevcaz.github.io/notes/ffmpeg/concatenateaudiofiles/
	mkdir -p /tmp/merge_to_mp3
	local stamp=$(make_timestamp)
	local tmppath=/tmp/merge_to_mp3/$stamp
	mkdir $tmppath

	local contextpath=$(dirname ${a[1]})

	# convertion to pcm
	for f in $@
	do
	  ffmpeg -i $f -c:a pcm_s16le -ac 2 -ar 48000 -f s16le $tmppath/${f%.*}.pcm
	done

	# concatenate files
	cat $tmppath/*.pcm > $tmppath/RESULT_$stamp.pcm
	ffmpeg -f s16le -ac 2 -ar 48000 -i $tmppath/RESULT_$stamp.pcm -ar 44100 -ac 2 -b:a 96k -map a "$contextpath/RESULT_$stamp.mp3"
}

veedio () {
	case $1 in
		(cut) ffmpeg -ss $3 -to $4 -i "$2" -vn -ar 44100 -ac 2 -b:a 96k -map a "$5" ;;
		(*) echo "unreckognized command '$1'" ;;
	esac
}

no_crash_report () {
	launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
	sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist
}

# Activate or deactivate mediaanalysisd agent.
config_mediaanalysis () {
	case $1 in
		off)
			launchctl kill -STOP user/$(id -u)/com.apple.mediaanalysisd
		;;
		on)
			launchctl kill -CONT user/$(id -u)/com.apple.mediaanalysisd
		;;
		*)
			echo "unreckognized command '$1"
			return 1
		;;
	esac
}

# Activate or deactivate photoanalysisd agent.
config_photoanalysis () {
	case $1 in
		off)
			launchctl kill -STOP user/$(id -u)//com.apple.photoanalysisd
		;;
		on)
			launchctl kill -CONT user/$(id -u)//com.apple.photoanalysisd
		;;
		*)
			echo "unreckognized command '$1"
			return 1
		;;
	esac
}

# Shows all available targets within makefile.
make_list_targets () {
	make -f "$1" -qp | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | sort -u
}

# Cuts off portion of a video at the front and back.
trim_video () {
	case $1 in
		cut)
			ffmpeg -ss $3 -to $4 -i "$2" -acodec copy "$5"
		;;
		*)
			echo "unreckognized command '$1'"
		;;
	esac
}

convert_to_frame_sequence () {
	if [ $# -ne 3 ]; then
		echo "$0 [IN_FILE] [SEQUENCE_ROOT] [FRAME_RATE]"
		return 1
	fi

	local infile="$(realpath $1)"
	local seq_root="$(realpath $2)"
	local framerate=$3
	local framepattern=out%06d.png
	
	mkdir -p ${seq_root}
	pushd ${seq_root} > /dev/null
		ffmpeg -i "$infile" -vf fps=$framerate ${framepattern}
	popd > /dev/null
	# ffprobe -v 0 -of compact=p=0 -select_streams 0 -show_entries stream=r_frame_rate 'The Master (2012).mp4'
}

convert_from_frame_sequence () {
	if [ $# -ne 3 ]; then
		echo "$0 [IMG_SEQ_ROOT] [FRAME_PATTERN] [OUT_PATH]"
		return 1
	fi

	pushd $(realpath $1)
	ffmpeg -framerate 30 -pattern_type glob -i "$2" -c:v libx264 -pix_fmt yuv420p "$3"
	popd
}

convert_to_frame () {
	if [ $# -ne 3 ]; then
		echo "convert_to_frame [IN_PATH] [TIMESTAMP] [OUT_PATH]"
		return 1
	fi

	local in_file=$1
	# 00:00:16
	local timestamp=$2
	local out_file=$3

	ffmpeg -ss $timestamp -i "$in_file" -frames:v 1 "$out_file"
}

# Converts video to a series of images packaged in a gif container.
convert_to_gif () {
	if [ $# -ne 2 ]; then
		echo "convert_to_gif [IN_PATH] [OUT_PATH]"
		return 1
	fi

	local in_file=$1
	local out_file=$2

	ffmpeg -i "$in_file" \
		-filter_complex "[0:v] fps=12,scale=w=480:h=-1,split [a][b];[a] palettegen=stats_mode=single [p];[b][p] paletteuse=new=1" \
		"$out_file"
}

# Exports up to 2 audio channels from input file and creates mp3 from it.
convert_to_mp3 () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp3 [IN_PATH] [OUT_PATH]"
		return $#
	fi

	local in_file=$1
	local out_file=$2

	# -map a / strips artwork
	ffmpeg -i "$in_file" -vn -ar 44100 -ac 2 -b:a 96k -map a "$out_file"

	return $?
}

convert_to_pcm () {
	if [ $# -ne 2 ]; then
		echo "convert_to_pcm [IN_PATH] [OUT_PATH]"
		return $#
	fi

	local in_file=$1
	local out_file=$2

	# -map a / strips artwork
	ffmpeg -i "$in_file" -c:a pcm_s16le -ac 2 -ar 48000 -f s16le -map a "$out_file"

	return $?
}

convert_to_wav () {
	if [ $# -ne 2 ]; then
		echo "convert_to_wav [IN_PATH] [OUT_PATH]"
		return $#
	fi

	local in_file=$1
	local out_file=$2

	# -map a / strips artwork
	ffmpeg -i "$in_file" -acodec pcm_mulaw -ac 2 -ar 44100 "$out_file"

	return $?
}

convert_to_webm () {
	local in_file="$1"
	local out_file="$2"

	ffmpeg -i "$in_file" \
		-c:v libvpx-vp9 -preset 4 \
		-crf 30 -g 240 -pix_fmt yuv420p \
		-c:a libopus \
		"$out_file"
}

convert_to_webm_scaled () {
	if [ $# -ne 3 ]; then
		echo "USAGE: $0 [IN_PATH] [HEIGHT] [OUT_PATH]"
		return 13
	fi

	local in_file="$1"
	local h="$2"
	local out_file="$3"

	ffmpeg -i "$in_file" \
		-c:v libvpx-vp9 -preset 4 \
		-crf 30 -g 240 -pix_fmt yuv420p \
		-vf scale=-1:$h \
		-c:a libopus \
		"$out_file"
}

# Converst input to mp4 using gpu acceleration.
convert_to_mp4_gpu () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH]"
		return 1
	fi

	# local base_path="$(dirname $1)"
	# local filename_without_ext="$(basename $1 .mkv)"

	# local in_file="$base_path/$filename_without_ext.mkv"
	# local out_file="$base_path/$filename_without_ext.mp4"
	local in_file=$1
	local out_file=$2

	#ffmpeg -i "$in_file" -c:v libx264 "$out_file"
	ffmpeg -i "$in_file" -acodec copy -c:v h264_videotoolbox -pix_fmt yuv420p -profile:v main -level:v 3.1 "$out_file"

	return $?
}

# Converts input file to mp4.
convert_to_mp4_ping_pong_loop () {
	if [ $# -eq 2 ]; then
		local in_file=$1
		local out_file=$2

		# ping pong loopn
		ffmpeg -i "$in_file" \
			-filter_complex "[0:v]reverse,fifo[r];[0:v][r] concat=n=2:v=1 [v]" \
			-map "[v]" "$out_file"

		return $?
	elif [ $# -eq 4 ]; then
		local in_file=$1
		local out_file=$2
		local start_cut=$3
		local end_cut=$4

		# ping pong loopn
		ffmpeg -ss $start_cut -to $end_cut -i "$in_file" \
			-filter_complex "[0:v]reverse,fifo[r];[0:v][r] concat=n=2:v=1 [v]" \
			-map "[v]" "$out_file"

		return $?
	fi

	echo "convert_to_mp4_ping_pong_loop [IN_PATH] [OUT_PATH]"
	return 1
}

# Converts input file to mp4.
convert_to_mp4 () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH]"
		return 1
	fi

	local in_file=$1
	local out_file=$2

	ffmpeg -i "$in_file" -acodec copy -c:v libx264 -pix_fmt yuv420p -profile:v main -level:v 3.1 "$out_file"

	return $?
}

# Converts input file to mp4.
convert_to_mp4_strict () {
	if [ $# -ne 2 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH]"
		return 1
	fi

	local in_file=$1
	local out_file=$2

	ffmpeg -i "$in_file" -acodec copy -c:v libx264 \
		-pix_fmt yuv420p -profile:v main -level:v 3.1 -strict -2 \
		"$out_file"

	return $?
}

convert_to_mp4_cropped () {
	if [ $# -ne 4 ]; then
		echo "convert_to_mp4 [IN_PATH] [OUT_PATH] [WIDTH] [HEIGHT]"
		return 1
	fi

	local in_file=$1
	local out_file=$2
	local w=$3
	local h=$4

	ffmpeg -i "$in_file" -filter:v "crop=$w:$h:0:0" -acodec copy -c:v libx264 -pix_fmt yuv420p -profile:v main -level:v 3.1 "$out_file"

	return $?
}

convert_to_mp4_scaled () {
	if [ $# -ne 3 ]; then
		echo "convert_to_mp4_scaled [IN_PATH] [OUT_PATH] [HEIGHT]"
		return 1
	fi

	local in_file=$1
	local out_file=$2
	local h=$3

	ffmpeg -i "$in_file" -vf scale=-1:$h -acodec copy -c:v libx264 \
		-pix_fmt yuv420p -profile:v main -level:v 3.1 \
		"$out_file"
}

convert_to_mp4_scaled_xy () {
	if [ $# -ne 4 ]; then
		echo "convert_to_mp4_scaled [IN_PATH] [OUT_PATH] [WIDTH] [HEIGHT]"
		return 1
	fi

	local in_file=$1
	local out_file=$2
	local w=$3
	local h=$4

	ffmpeg -i "$in_file" -vf scale=$w:$h -acodec copy -c:v libx264 \
		-pix_fmt yuv420p -profile:v main -level:v 3.1 \
		"$out_file"
}

init_ssh () {
	eval `ssh-agent` && (
		for key in $(cat "$HOME/.ssh/keys"); do
			ssh-add "$HOME/.ssh/$key"
		done
	)
}

open_pdf () {
	if [ $# -ne 1 ]; then
		echo "no file given!"
		return 1
	fi

	# double fork it !!!
	(mupdf "$1" &) &
}

#
calc () {
	[ $# -ne 1 ] && {
		echo "just one string with calculation pleazz!"
		return 1
	}

	echo "phi=(sqrt(5)+1)/2;phi1=phi-1;phi1i=1-phi1;pi=4*a(1);tau=2*pi; $1" | bc -l
}

#
drossel () {
	[ $# -ne 2 ] && {
		echo "nöööööö"
		return 1
	}

	local iface="$1"
	local speed="$2"

	which wondershaper > /dev/null && {
		sudo wondershaper clear && \
		sudo wondershaper "$iface" "${speed}0" "${speed}0"
	} || {
		exit 1
	}
}

#
find_string () {
	[ $# -ne 2 ] && {
		echo "usage: find_string <directory> <searchstring>"
		return 1
	}

	find "$1" -type f | xargs -I{} fgrep --color=always -Hno "$2" "{}"

	return 0
}

#
show_connections () {
	sudo netstat -natp
}

#
find_here () {
	find . -iname "$1"
}

#
who_uses_port () {
	local port=$1

	lsof -Pnl +M -i4 | grep ":$port"

	[ $? -eq 1 ] && {
		echo "nobody uses port "$port
	}
}

# frontend for rsync
netcp () {
	local user="$1"
	local addr="$2"
	local port="$3"
	local src="$4"
	local dst="$5"

	rsync -aP -e "ssh -p$port" "$user@$addr:$src" "$dst"
}

# ex - archive extractor
# usage: ex <file>
ex () {
	if [ -f $1 ] ; then
		case $1 in
			*.tar.bz2)   tar xjf $1   ;;
			*.tar.gz)    tar xzf $1   ;;
			*.bz2)       bunzip2 $1   ;;
			*.rar)       unrar x $1   ;;
			*.gz)        gunzip $1    ;;
			*.tar)       tar xf $1    ;;
			*.tbz2)      tar xjf $1   ;;
			*.tgz)       tar xzf $1   ;;
			*.zip)       unzip $1     ;;
			*.Z)         uncompress $1;;
			*.7z)        7z x $1      ;;
			*)           echo "'$1' cannot be extracted via ex()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

cleanup_caches () {
	rm -rf ~/.thumbnails
	mkdir -p ~/.thumbnails

	rm -rf ~/.cache
	mkdir -p ~/.cache
}

#
top_biggies () {
	local search_path="$1"
	if ((0 == $#)); then
		search_path=./
	fi

	du -h "$search_path" | sort -rh | head -11
}

#
top_biggies_su () {
	local search_path="$1"
	if ((0 == $#)); then
		search_path=./
	fi

	sudo du -h "$search_path" | sort -rh | head -11
}

#
git-custom-fix-lfs () {
	if [ $# -lt 1 ]; then
		echo "Please specify path!"
		return
	fi

	git lfs migrate import --no-rewrite $*
}

#
git-custom-rm-submodule () {
	if [ $# -lt 1 ]; then
		echo "Please specify submodule name!"
		return
	fi

	git submodule deinit -f -- "$1"
	rm -rf ".git/modules/$1"
	git rm --cached "$1"
}

#
git-custom-show-all-tags () {
	if [ "$1" = "-v" ]; then
		git log --no-walk --tags --pretty="%H %d" --decorate=full
	else
		git tag
	fi
}

#
git-custom-exterminate () {
	if [ "$1" = "" ]; then
		echo "You have to specifiy the path of the file to destroy!"
		exit
	fi

	echo "This will delete all references of $1!"
	echo "Please back up your data, before running this command!"
	echo "Continue?[y/n] > "

	read cont

	if [ "$cont" = "y" ]; then
		git filter-branch --force \
		--index-filter "git rm --cached --ignore-unmatch $1" \
		--prune-empty --tag-name-filter cat -- --all

		if [ $? -ne 0 ]; then
			echo "Something went wrong!"
		else
			echo "You rewrote history! Be proud of yourself!"
		fi
	else
		echo "Ending without rewrite."
	fi
}

#
git-custom-github-info () {
	#if private
	#curl -s -H "Authorization: token GITHUB_TOKEN" https://api.github.com/repos/torvalds/linux 
	#else
	local resource_path=$(echo $1 | perl -ne 'print $1 if m!([^/]+/[^/]+?)(?:\.git)?$!')
	local api_url="https://api.github.com/repos/$resource_path"
	local cache_path="/tmp/git-meta/${resource_path}"

	mkdir -p ${cache_path}
	
	echo "API query at '${api_url}' ..." > /dev/stderr
	if [ -e "${cache_path}/info.json" ]; then
		echo "Found cached version." > /dev/stderr
	else
		echo "Fetching metadata for '${api_url}' ..." > /dev/stderr
		wget -O "${cache_path}/info.json" "${api_url}" 2>&1 > /dev/null
	fi

	ls -lav "${cache_path}/info.json"
	cat "${cache_path}/info.json"
}
